- root node children can be found by getting start and end parentheses

- if there has been an even number of left and right parentheses pass and there is a comma (delimter) then it is a child of the current node
    - use this logic to find all "children strings"
- will need to recurse through found children to convert them to nodes
    - if there is a single set of parentheses then you are at a leaf node
    - if there isnt then recurse
        - use same logic to find "children strings"
        - check and recurse
        - can add product of recursion to current node


- recursive process:
  - create a node N
  - get outer most pair location
  - parse what is inside outer most pair
  - if pure value:
    - add to node N
  - else if a node type:
    - create node type NN for it
    - repeat recursive process for this node NN
    - add result of NN to N (and so forth further down)




- depth process:
  - start at root
  - evaluate each child recursively
  - take max value and min value of children + 1

  - evaluate process:
    - pass through depth paramter
    - for each child:
      - if node:
        - evaluate with depth + 1
      - else if leaf:
        - return depth
      - get min/max of evluation 
